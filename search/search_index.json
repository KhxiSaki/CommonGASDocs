{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>Thinking of using Gameplay Ability system but in need of a starting point to start your project? Common GAS is a plugin that provides starting point for your project and using the power of Epic\u2019s Gameplay Ability System to speed up your project development</p> <p>What is Gameplay Ability System?</p> <p><code>The Gameplay Ability System is a highly flexible framework for building the types of abilities and attributes that you might find in an RPG or MOBA title. You can build actions or passive abilities for the characters in your games to use, and status effects that can build up or wear down various attributes as a result of these actions, additionally you can implement \"cooldown\" timers or resource costs to regulate the usage of these actions, change the level of the ability and its effects at each level, activate particle, sound effects, and more. The Gameplay Ability System can help you to design, implement, and efficiently network in-game abilities from as simple as jumping to as complex as your favorite character's ability set in any modern RPG or MOBA title.</code> Offical Documentation</p>"},{"location":"#how-to-contact-us","title":"How to contact us:","text":"<ul> <li>Discord: LINK</li> <li>Youtube: LINK</li> </ul>"},{"location":"StateTree/","title":"StateTree","text":""},{"location":"StateTree/#commonaipawnwith-state-tree","title":"CommonAIPawnWith State Tree","text":""},{"location":"aimodule/","title":"How to AI","text":"<p>In Common GAS, you can choose to either use <code>StateTree</code> or the standard <code>AIModule</code> when it comes to build an AI system. I already provided you with some helpful <code>Decorators</code>and <code>Tasks</code> if you using the standard AIModule but if you're using <code>StateTree</code>, we dont provided any decorators and tasks as i havent battle tested StateTree enough but in the future, maybe i will provided some so you can still build your ai logic with <code>StatetTree</code></p> <p></p> <p>In this example, im going to show you the basic setup to get you going.</p>"},{"location":"aimodule/#setup","title":"Setup","text":"<ul> <li> <p>By Default, CommonGAS already enabled <code>AIModule</code> ,<code>StateTree</code> and <code>GameplayStateTree</code> if you're planning to use that plugin and added them as dependecies.  </p> </li> <li> <p>For any AI-controlled characters, they need to inherit from <code>CommonModularPawn</code> and <code>CommonAIPawnWithStateTree</code> if you're planning to use StateTree</p> </li> </ul> <p></p> <p></p> <ul> <li>Next, you need to make an <code>AIController</code> inherit from <code>CommonModularAIController</code> to control the AI.</li> </ul> <p></p> <ul> <li> <p>In the blueprint graph, on <code>BeginPlay</code> we simply call the <code>Run Behaviour Tree</code> and apply your behaviour tree asset. </p> </li> <li> <p>Lastly, in your <code>pawn</code> class class default, find <code>Pawn-&gt;Ai Controller Class</code> and set your AIController to the one we created.</p> </li> </ul> <p>Now, thats the basic setup that should get you going. Have fun building your AIs!</p>"},{"location":"aimodule/#tasks","title":"Tasks","text":"<p>In Common GAS, i have provided you with some useful <code>Tasks</code> you can use with GAS to build your gameplay logic:</p>"},{"location":"aimodule/#bttask_activateabilitybyclass","title":"BTTask_ActivateAbilityByClass","text":""},{"location":"aimodule/#bttask_activateabilitybytags","title":"BTTask_ActivateAbilityByTags","text":""},{"location":"aimodule/#bttask_activateabilityonce","title":"BTTask_ActivateAbilityOnce","text":""},{"location":"aimodule/#bttask_addloosegameplaytag","title":"BTTask_AddLooseGameplayTag","text":""},{"location":"aimodule/#bttask_addloosegameplaytags","title":"BTTask_AddLooseGameplayTags","text":""},{"location":"aimodule/#bttask_applygameplayeffecttoself","title":"BTTask_ApplyGameplayEffectToSelf","text":""},{"location":"aimodule/#bttask_applygameplayeffecttotarget","title":"BTTask_ApplyGameplayEffectToTarget","text":""},{"location":"aimodule/#bttask_removelooosegameplaytags","title":"BTTask_RemoveLoooseGameplayTags","text":""},{"location":"aimodule/#bttask_removeloosegameplaytag","title":"BTTask_RemoveLooseGameplayTag","text":""},{"location":"aimodule/#bttask_sendgameplayevent","title":"BTTask_SendGameplayEvent","text":""},{"location":"aimodule/#decorators","title":"Decorators","text":"<p>In Common GAS, i have provided you with some useful <code>Decorators</code> you can use with GAS to build your gameplay logic:</p>"},{"location":"aimodule/#btdecorator_hasallgameplaytags","title":"BTDecorator_HasAllGameplayTags","text":""},{"location":"aimodule/#btdecorator_hasanymatchinggameplaytags","title":"BTDecorator_HasAnyMatchingGameplayTags","text":""},{"location":"aimodule/#btdecorator_hasmatchinggameplaytag","title":"BTDecorator_HasMatchingGameplayTag","text":""},{"location":"aimodule/#btdecorator_isabilitysystemcomponentvalid","title":"BTDecorator_IsAbilitySystemComponentValid","text":""},{"location":"api/","title":"Api","text":""},{"location":"api/#api","title":"API","text":""},{"location":"api/#commongameplayability","title":"CommonGameplayAbility","text":"<p> Class Defaults </p> <p>Map of gameplay tags to gameplay effect containers and Boolean check if an ability to be granted on granted</p> <p></p> Context Config directory Effect Container Map An array of CommonEffectContainer reference Activate Ability On Granted Boolean"},{"location":"api/#ongiveability","title":"OnGiveAbility","text":"<p>Called when the ability is given to an AbilitySystemComponent</p> <p></p>"},{"location":"api/#onremoveability","title":"OnRemoveAbility","text":"<p>Called when the ability is removed from an AbilitySystemComponent </p> <p></p>"},{"location":"api/#onavatarset","title":"OnAvatarSet","text":"<p>If an ability is marked as 'ActivateAbilityOnGranted', activate them immediately when given here</p> <p></p>"},{"location":"api/#commonabilitysystemcomponent","title":"CommonAbilitySystemComponent","text":""},{"location":"api/#commonabilitysystemlibrary","title":"CommonAbilitySystemLibrary","text":"<p>GetActiveAbilitiesWithTags Return a list of all active abilities with given ability tags container</p> <p>Input</p> <p>Ability Tags Gameplay Tag Container</p> <p>Output</p> <p>Active Abilities An array of CommonGameplayAbility </p> <p>GetCooldownRemainingTag Returns total time and remaining time for cooldown tags. Returns false if no active cooldowns found</p> <p>Input</p> <p>Cooldown Tags Gameplay Tag Container</p> <p>Output</p> <p>Time Remaining Float Cooldown Duration Float Return Value Float</p> <p>ActivateAbilitiesWithTags Attempts to activate all abilities that match the specified tags Returns true if it thinks it activated, but it may return false positives due to failure later in activation. If bAllowRemoteActivation is true, it will remotely activate local/server abilities, if false it will only try to locally activate the ability</p> <p>Input Ability Tags Gameplay Tag Container Allow Remote Activation Boolean</p> <p>Output Return Value Boolean</p> <p>GrantAbility Grant a gameplay ability to owner Abilitysystemcomponent\u2019s list of active abilities</p> <p>Input</p> <p>New Ability Gameplay Ability class reference</p> <p>RemoveAbility Remove a gameplay ability from owner Abilitysystemcomponent\u2019s list of active abilities</p> <p>Input</p> <p>Ability Gameplay Ability class reference</p> <p>DoesEffectContainerSpecHaveEffects</p> <p>Input</p> <p>Container Spec CommonEffectContainerSpec reference</p> <p>Output</p> <p>Return Value Boolean</p> <p>ClearEffectContainerSpecTargets</p> <p>Input</p> <p>Container Spec CommonEffectContainerSpec reference</p> <p>DoesEffectContainerSpecHaveTargets</p> <p>Input</p> <p>Container Spec CommonEffectContainerSpec reference</p> <p>Output</p> <p>Return Value Boolean</p> <p>AddTargetsToEffectContainerSpec</p> <p>Input</p> <p>Container Spec CommonEffectContainerSpec reference Hit Results An array of hit result reference Target Actors An array of actor reference</p> <p>Output</p> <p>Return Value CommonEffectContainerSpec </p> <p>ApplyExternalEffectContainerSpec</p> <p>Input</p> <p>Container Spec CommonEffectContainerSpec reference</p> <p>Output</p> <p>Return Value An array of ActiveGameplayEffectHandle reference</p> <p>GameplayTasks PlayMontageAndWaitForEvent</p> <p>Input</p> <p>Task Instance Name FName Montage To Play UAnimMontage Event Tags GameplayTagContainer Rate Float Start Section FName Stop when Ability Ends Boolean Anim Root Motion Translation Scale Float</p> <p>Output</p> <p>Async Task</p> <p>On Completed  The montage completely finished playing  On Blend Out  The montage started blending out  On Interrupted The montage was interrupted  On Cancelled  The ability task was explicitly cancelled by another ability  Event Received  One of the triggering gameplay events happened  Event Tags GameplayTag Event Data GameplayEventData</p>"},{"location":"asyncaction_listenforgameplaymessage/","title":"AsyncAction_ListenForGameplayMessage","text":"<p>insert something here</p>"},{"location":"attributes/","title":"How to use AttributeSet","text":"<p>The Gameplay Ability System uses Gameplay Attributes (FGameplayAttribute) to store, calculate, and modify gameplay-related floating-point values. These values can describe any trait of their owners, such as a character's remaining health points, a vehicle's top speed, or the number of times an item can be used before it breaks. Actors in the Gameplay Ability System store their Gameplay Attributes in an Attribute Set, which helps to manage interactions between Gameplay Attributes and other parts of the system, and registers itself with the Actor's Ability System Component. These interactions include clamping to value ranges, performing calculations that apply temporary value changes, and reacting to events that permanently alter their base values.(taken from Epic\u2019s Documentation) Attribute Set Gameplay Events ( Coming Soon)</p>"},{"location":"attributes/#adding-new-attribute","title":"Adding New Attribute","text":"<p>Taken from : Official Documentation</p> <p>Extend the base Attribute Set class, UAttributeSet, and add your Gameplay Attributes as FGameplayAttributeData UProperties. A simple Attribute Set with one Gameplay Attribute might look like this:</p> <pre><code>GENERATED_BODY()\n\npublic:\n/** Sample \"Health\" Attribute, publicly accessible */\nUPROPERTY(EditAnywhere, BlueprintReadOnly)\nFGameplayAttributeData Health;\n</code></pre> <p>Store the Attribute Set on the Actor, and expose it to the engine. Use the const keyword to ensure that code cannot modify the Attribute Set directly. Add this to your Actor's class definition:</p> <pre><code>/** Sample Attribute Set. */ UPROPERTY() const UMyAttributeSet* AttributeSet;\n</code></pre> <p>Register the Attribute Set with the appropriate Ability System Component. This happens automatically when you instantiate the Attribute Set, which you can do in the Actor's constructor, or during BeginPlay, as long as the Actor's GetAbilitySystemComponent function returns a valid Ability System Component at the moment of instantiation. You can also edit the Actor's Blueprint and add the Attribute Set type to the Ability System Component's Default Starting Data. A third method is to instruct the Ability System Component to instantiate the Attribute Set, which will then register it automatically, as in this example: </p> <pre><code>// Get the UMyAttributeSet from our Ability System Component. The Ability System Component will create and register one if needed.\nAttributeSet = ASC-&gt;GetSet&lt;UMyAttributeSet&gt;();\n\n// We now have a pointer to the new UMyAttributeSet that we can use later. If it has an initialization function, this is a good place to call it.\n</code></pre> <p>After adding these, your Attribute Set class definition should look like this: </p> <pre><code>UCLASS()\nclass MYPROJECT_API UMyAttributeSet : public UCommonAttributeSet\n{\n    GENERATED_BODY()\n\n    protected:\n    /** Sample \"Health\" Attribute */\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    FGameplayAttributeData Health;\n\n    //~ ... Other Gameplay Attributes here ...\n\n    public:\n    //~ Helper functions for \"Health\" attributes\n    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(UMyAttributeSet, Health);\n    GAMEPLAYATTRIBUTE_VALUE_GETTER(Health);\n    GAMEPLAYATTRIBUTE_VALUE_SETTER(Health);\n    GAMEPLAYATTRIBUTE_VALUE_INITTER(Health);\n\n    //~ ... Helper functions for other Gameplay Attributes here ...\n};\n</code></pre>"},{"location":"attributes/#initialization","title":"Initialization","text":"<p>Taken from : Official Documentation</p> <p>If you choose not to initialize your Attribute Set and its Gameplay Attributes by calling an initialization function with hard-coded values, you can do so with a Data Table using the Gameplay Ability System row type called \"AttributeMetaData\". You can import data from an external file, or manually populate the Data Table in the editor. </p> <p></p> <p><code>When creating the Data Table Asset, choose \"AttributeMetaData\" as the row type.</code></p> <p><code>Importing Data Tables</code></p> <p>Developers usually import their tables from .csv files like the following:</p> <pre><code>---,BaseValue,MinValue,MaxValue,DerivedAttributeInfo,bCanStack\nMyAttributeSet.Health,\"100.000000\",\"0.000000\",\"150.000000\",\"\",\"False\"\n</code></pre> <p></p> <p><code>When importing a .csv file as a Data Table Asset, select the \"AttributeMetaData\" row type.</code></p> <p>You can append additional rows to support Attribute Sets with multiple Gameplay Attributes. In the file shown above, the \"Health\" Gameplay Attribute within UMyAttributeSet (the reflection system drops the \"U\" prefix) will initialize with a value of 100. It has no derived information and does not stack.</p> <p>Note:</p> <pre><code>Although there are columns for MinValue (0.0) and MaxValue (150.0), Gameplay Attributes and Attribute Sets do not feature a built-in clamping behavior; the values in these columns have no effect.\n</code></pre> <p><code>Manually Populating Data Tables</code></p> <p>If you prefer to edit values in Unreal Editor rather than an external spreadsheet or text-editor program, you can do so by creating your table and opening it like any other Blueprint Asset. Use the Add button at the top of the window to add a row for each Gameplay Attribute. Keep in mind that the naming convention is AttributeSetName.AttributeName, and it is case-sensitive.</p> <p>Note:</p> <pre><code>The \"Min Value\" and \"Max Value\" columns are not implemented in the default Gameplay Ability System Plugin; these values do not have any effect.\n</code></pre> <p><code>Controlling Gameplay Attribute Access</code></p> <p>Controlling direct access to the Gameplay Attributes is a good way to ensure that their values are always within the limits that you set for them. This is done through the Ability Set, not by extending <code>FGameplayAttributeData</code>; <code>FGameplayAttributeData</code> only stores and provides access to the Gameplay Attribute's data.</p> <p>To restrict the value of the \"Health\" Gameplay Attribute so that it can never go below zero, you can write your own getter and setter functions. Remove the <code>GAMEPLAYATTRIBUTE_VALUE_GETTER</code> and <code>GAMEPLAYATTRIBUTE_VALUE_SETTER</code> macros, replacing them with function headers:</p> <pre><code>GAMEPLAYATTRIBUTE_PROPERTY_GETTER(UMyAttributeSet, Health);\nfloat GetHealth() const;\nvoid SetHealth(float NewVal);\nGAMEPLAYATTRIBUTE_VALUE_INITTER(Health);\n</code></pre> <p>Define these functions in your Attribute Set's source file:</p> <pre><code>float UMyAttributeSet::GetHealth() const\n{\n    // Return Health's current value, but never return a value lower than zero.\n    // This is the value after all modifiers that affect Health have been considered.\n    return FMath::Max(Health.GetCurrentValue(), 0.0f);\n}\n\nvoid UMyAttributeSet::SetHealth(float NewVal)\n{\n    // Do not accept values lower than zero.\n    NewVal = FMath::Max(NewVal, 0.0f);\n\n    // Make sure we have an Ability System Component instance. This should always be the case.\n    UAbilitySystemComponent* ASC = GetOwningAbilitySystemComponent();\n    if (ensure(ASC))\n    {\n        // Set the base value (not the current value) through the appropriate function.\n        // This makes sure that any modifiers we have applied will still work properly.\n        ASC-&gt;SetNumericAttributeBase(GetHealthAttribute(), NewVal);\n    }\n}\n\nAbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(AttributeSet-&gt;GetHealthAttribute()).AddUObject(this, &amp;AGASAbilityDemoCharacter::OnHealthChangedInternal);\n</code></pre> <p><code>Interactions with Gameplay Effects</code></p> <p>A common way to exercise control over the value of a Gameplay Attribute is to handle [Gameplay Effects] as they relate to it.</p> <p>Begin by overriding the PostGameplayEffectExecute function in your Attribute Set's class definition. This function should be at the public access level.</p> <p><code>void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData&amp; Data) override;</code></p> <p>Write the function body in the Attribute Set's source file, making sure to call the parent class' implementation.</p> <pre><code>// Remember to call the parent's implementation.\nSuper::PostGameplayEffectExecute(Data);\n\n// Check to see if this call affects our Health by using the Property Getter.\nif (Data.EvaluatedData.Attribute == GetHealthAttribute())\n{\n    // This Gameplay Effect is changing Health. Apply it, but restrict the value first.\n    // In this case, Health's base value must be non-negative.\n    SetHealth(FMath::Max(GetHealth(), 0.0f));\n}\n</code></pre> <p><code>Replication</code></p> <p>For multiplayer projects, you can replicate your Gameplay Attribute through the Attribute Set similar to how you would replicate any other property.</p> <p>Begin by adding the ReplicatedUsing Specifier to your property's definition in the Attribute Set header file. This will set up a callback function that helps with prediction on remote systems.</p> <pre><code>protected: \n/** Sample \"Health\" Attribute */ \n(EditAnywhere, BlueprintReadOnly, ReplicatedUsing = OnRep_Health) FGameplayAttributeData Health;\n</code></pre> <p>Declare your replication callback function: <code>/** Called when a new Health value arrives over the network */  UFUNCTION() virtual void OnRep_Health(const FGameplayAttributeData&amp; OldHealth);</code></p> <p>In the Attribute Set's source file, define your replication callback function. The body of the function can be expressed as a single macro that the Gameplay Ability System defines.</p> <pre><code>// Use the default Gameplay Attribute System repnotify behavior.\n    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Health, OldHealth);\n</code></pre> <p>If this is the first replicated property in your Attribute Set, set up an override for the public GetLifetimeReplicatedProps function.</p> <pre><code> /** Marks the properties we wish to replicate */ \n virtual void GetLifetimeReplicatedProps(TArray&amp; OutLifetimeProps) const override;\n</code></pre> <p>If this is the first replicated property in your Attribute Set, set up an override for the public GetLifetimeReplicatedProps function.</p> <pre><code>/** Marks the properties we wish to replicate */ \nvirtual void GetLifetimeReplicatedProps(TArray&amp; OutLifetimeProps) const override;\n</code></pre> <p>Add the Gameplay Attribute to the Attribute Set's GetLifetimeReplicatedProps function in its source file, as follows:</p> <pre><code>// Call the parent function.\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n    // Add replication for Health.\n    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Health, COND_None, REPNOTIFY_Always);\n</code></pre>"},{"location":"attributes/#how-does-attribute-work","title":"How Does Attribute Work?","text":"<p>Each of these attributes is defined as an FGameplayAttributeData structure, which stores a Base value that is only modified by permanent changes and a Current value which is modified by temporary buffs/debuffs. The class uses some macros to add boilerplate code to handle modification and replication of these attributes. </p> <ol> <li> <p>Before attributes are modified, the PreAttributeChange function handles scaling the current health/mana with the max value. </p> </li> <li> <p>After attributes are modified, the PostGameplayEffectExecute function handles clamping and notifying other objects about the changes. </p> </li> </ol> <p><code>How Damage is handled in Action RPG Game Sample</code></p> <p>ActionRPG</p> <p>Before damage can be applied, a character needs to have Health &gt; 0. There are several ways to initialize default values for attributes, but for ARPG we decided to initialize them using a Stats GameplayEffect. </p> <p>The Stats gameplay effect is applied in  <code>ARPGCharacterBase::AddStartupGameplayAbilities</code> where it reads the list of PassiveGameplayEffects from the character Blueprint and applies them, at the current CharacterLevel. </p> <p>Note:</p> <p><code>In CommonGAS, this functionality is being replaced by UCommonAbilitySet.Its provides the same functionality but using data asset,programmer/designer doesnt have to manually adding them but just give this data asset to character and it automatically applied.</code></p> <p>If CharacterLevel changes, it removes and re-adds them at the new level. Here is what the GE_StatsBase gameplay effect used for NPCs looks like inside the Unreal Engine 4 (UE4) editor: </p> <p></p> <p>The Instant duration means that this is applied permanently precisely one time. Then for each of the primary stats, there is an Attribute Modifier that overrides the value based on a CurveTable. StartingStats is imported from a CSV in Abilities/DataTables and has a row for each stat and a column for each level. In this case, it will look at the DefaultMaxHealth row, and the column will be CharacterLevel. The GE_PlayerStats effect inherits from this generic effect and changes all the rows to be PlayerMaxHealth and so forth. By using Curve Tables in this way, it is easy to rebalance attributes for the entire game at once, without having to modify each individual effect by hand. You can also set up scripts outside the game to create CSV or JSON files from external data sources like Excel and import those as needed.</p> <p>Mana is changed using simple Modifiers with the Add operation, but to do damage, the RPGDamageExecution class is used. The execution calculations consist of two parts, a set of capture declarations and an execution function. The capture declaration macros register information with the UE4 Editor, so Gameplay Effects can use the execution in your project. For each captured attribute, the list of currently active temporary modifiers is captured along with their gameplay tags. Then in URPGDamageExecution::Execute_Implementation it applies only those modifiers that match the Gameplay Tags that were passed in at effect execution time. After combining those modifiers to get a \"calculated\" number for Damage, AttackPower, and DefensePower, it turns that into \"final\" damage using the formula SourceDamage * AttackPower / DefensePower. The final damage then turns into a Health modifier in URPGAttributeSet::PostGameplayEffectExecute. Here is what GE_DamageBase looks like:</p> <p></p> <p>The Damage done comes from the DefaultAttack row in AttackDamage, but you can also apply a per-attack multiplier by changing the 1.0 scale to the left of the Curve Table reference. The Source/Target tags allow setting the Require/Ignore tags for filtering, in this case, the damage will not be applied if the target has the tag Status.DamageImmune. Each individual attack subclasses GE_DamageBase and modifies the tags or modifiers as needed.</p> <p>Note: <code>In the future, CommonGAS with have damage and healing functionality similiar to how ActionRPG does.</code></p> <p>Taken from : Official Documentation</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#11-unreal-engine-511","title":"1.1 (Unreal Engine 5.1.1)","text":"<ul> <li>Fix visibility for some Decorators and Tasks (Bugfixes)</li> <li>Remove old exposes function inside CommonModMagnitudeCalculation (Bugfixes)</li> </ul>"},{"location":"changelog/#1101-unreal-engine-511","title":"1.1.01 (Unreal Engine 5.1.1)","text":"<ul> <li>Fix some leftover naming from previous code merge back in september 2022 (Bugfixes)</li> <li>K2_OnPawnAvatarSet is not working due to not hook up to OnAvatarSet() (Bugfixes)</li> <li>Remove and backlog CommonAIPawn and CommonAIPawnWithStateTree (Removed)</li> <li>Remove default values of attributes in CommonAttributeSet constructor. we prefer to do this either using infinite GameplayEffect or data table (Bugfixes)</li> <li>Remove GrantAbility in extension component. prefer using ASC one. (Removed)</li> <li>Add new EGameplayEffectReplicationMode and PostInitiProperties() in CommonModularPawn,CommonModularActor,CommonModularCharacter (New)</li> <li>Add Default Character Data (New)</li> <li>Add Input Mapping Data (New)</li> <li>Add CommonGASEditor Modules with new asset types for Common  classes and factory for custom CommonGAS category(New)</li> <li>Remove InputMappingContext and Input Priority from AbilityInputBindingComponent as this interaction being replaced by InputMappingData (Bugfixes)</li> <li>UAbilitySystemLibrary GameplayTags operation doesnt execute (bugfixes)</li> <li>Redo UGameplayCueFunction Library implemetations (Bugfixes)</li> </ul>"},{"location":"changelog/#1102-unreal-engine-520","title":"1.1.02 (Unreal Engine 5.2.0)","text":"<ul> <li>Fix undefined type 'USkeletalMeshComponent in CommonAbilitySystemComponent</li> <li>Fix 'AnimLayers': references must be initialized</li> <li>Fix use of undefined type 'FAnimMontageInstance'</li> <li>Clean up unused includes and forwards declarations</li> <li>Remove CommonInputComponent</li> <li>Fix use of undefined type 'APlayerController' in CommmonModularCharacter</li> </ul>"},{"location":"commonabilityinputbindingcomponent/","title":"Commonabilityinputbindingcomponent","text":"<p>insert something here</p>"},{"location":"commonabilityqueuecomponent/","title":"CommonAbilityQueueComponent","text":"<p>Coming Soon</p>"},{"location":"commonabilityset/","title":"Common Ability Set","text":""},{"location":"commonabilityset/#what-is-ability-set","title":"What is Ability Set?","text":"<p>Gameplay Ability Sets allow you define a set of abilities and effects which are given to the target ASC, I use these to apply the default generic abilities a player has, and default generic effects each player will have. These can also be used for things like perks, etc. The other benefit is, they can be added and removed via a simple handle.</p> <p>Taken from: thegames.dev</p>"},{"location":"commonabilityset/#what-does-ability-set-do","title":"What does Ability Set do?","text":"<p>In Lyra Game Sample, the ability set is being used to apply what default abilities, default attribute sets and default gameplay effects a character will have on startup. Their method of granting this to the owned character by using ULyraExperienceDefinition, ULyraPawnData, UGameFeatureAction_AddAbilities and ULyraEquipmentDefinitions Official Documentation</p>"},{"location":"commonabilityset/#how-does-common-gas-apply-the-ability-set","title":"How does Common GAS apply the ability set?","text":"<p>In Common GAS, the method of granting this ability set to player-controlled character is adding this in their <code>ACharacters-&gt;ACommonModularCharacter</code> blueprint character class CDO under <code>CommonGAS-&gt;Character-&gt;Abilities-&gt;AbilitySets</code></p> <p></p> <p>In c++, you can get a reference to <code>UCommonAbilitySet</code> and calling <code>GiveToAbilitySystem()</code> where you need to give it a valid UAbilitySystemComponent reference so it can add it to </p> <pre><code>UPROPERTY(ReplicatedUsing=OnRep_ActivateAbilities, BlueprintReadOnly, Category = \"Abilities\")\nFGameplayAbilitySpecContainer ActivatableAbilities;\n</code></pre> <p>for <code>Default Character Abilities</code>, <code>Default Gameplay Effects</code> will be added to <code>FActiveGameplayEffectHandle</code> and <code>Default Attribute Set</code> will be added using AbilitySystemComponent's <code>AddAttributeSetSubobject()</code></p> <p></p> <p></p> Name Functionality Granted Gameplay Abilities Gameplay abilities to grant when this ability set is granted. Granted Gameplay Effects Gameplay effects to grant when this ability set is granted. Granted Attributes Attribute sets to grant when this ability set is granted.o be applied on startup"},{"location":"commonabilitysystemcomponent/","title":"CommonAbilitySystemComponent","text":""},{"location":"commonabilitysystemcomponent/#what-is-abilitysystemcomponent","title":"What is AbilitySystemComponent?","text":"<p>A component to easily interface with the 3 aspects of the AbilitySystem:</p> <p>GameplayAbilities:</p> <ul> <li>Provides a way to give/assign abilities that can be used (by a player or AI for example)</li> <li>Provides management of instanced abilities (something must hold onto them)</li> <li>Provides replication functionality</li> <li>Ability state must always be replicated on the UGameplayAbility itself, but UAbilitySystemComponent provides RPC replication for the actual activation of abilities</li> </ul> <p>GameplayEffects:</p> <ul> <li>Provides an FActiveGameplayEffectsContainer for holding active GameplayEffects</li> <li>Provides methods for applying GameplayEffects to a target or to self</li> <li>wrappers for querying information in FActiveGameplayEffectsContainers (duration, magnitude, etc)</li> <li>Provides methods for clearing/remove GameplayEffects</li> </ul> <p>GameplayAttributes:</p> <ul> <li>Provides methods for allocating and initializing attribute sets</li> <li>Provides methods for getting AttributeSets</li> </ul> <p>The Ability System Component (UAbilitySystemComponent) is the bridge between Actors and the Gameplay Ability System. Any Actor that intends to interact with the Gameplay Ability System needs its own Ability System Component, or access to an Ability System Component owned by another Actor. Make sure that your project is set up to use the Gameplay Ability System Pluginbefore attempting to use the Ability System Component. Official Documentation</p> <p>The AbilitySystemComponent (ASC) is the heart of GAS. It's a UActorComponent (UAbilitySystemComponent) that handles all interactions with the system. Any Actor that wishes to use GameplayAbilities, have Attributes, or receive GameplayEffects must have one ASC attached to them. These objects all live inside of and are managed and replicated by (with the exception of Attributes which are replicated by their AttributeSet) the ASC. Developers are expected but not required to subclass this.</p> <p>The Actor with the ASC attached to it is referred to as the OwnerActor of the ASC. The physical representation Actor of the ASC is called the AvatarActor. The OwnerActor and the AvatarActor can be the same Actor as in the case of a simple AI minion in a MOBA game. They can also be different Actors as in the case of a player controlled hero in a MOBA game where the OwnerActor is the PlayerState and the AvatarActor is the hero's Character class. Most Actors will have the ASC on themselves. If your Actor will respawn and need persistence of Attributes or GameplayEffects between spawns (like a hero in a MOBA), then the ideal location for the ASC is on the PlayerState.</p> <p>Note: If your ASC is on your PlayerState, then you will need to increase the NetUpdateFrequency of your PlayerState. It defaults to a very low value on the PlayerState and can cause delays or perceived lag before changes to things like Attributes and GameplayTags happen on the clients. Be sure to enable Adaptive Network Update Frequency, Fortnite uses it.</p> <p>Both, the OwnerActor and the AvatarActor if different Actors, should implement the IAbilitySystemInterface. This interface has one function that must be overriden, UAbilitySystemComponent* GetAbilitySystemComponent() const, which returns a pointer to its ASC. ASCs interact with each other internally to the system by looking for this interface function.</p> <p>The ASC holds its current active GameplayEffects in FActiveGameplayEffectsContainer ActiveGameplayEffects.</p> <p>The ASC holds its granted Gameplay Abilities in FGameplayAbilitySpecContainer ActivatableAbilities. Any time that you plan to iterate over ActivatableAbilities.Items, be sure to add ABILITYLIST_SCOPE_LOCK(); above your loop to lock the list from changing (due to removing an ability). Every ABILITYLIST_SCOPE_LOCK(); in scope increments AbilityScopeLockCount and then decrements when it falls out of scope. Do not try to remove an ability inside the scope of ABILITYLIST_SCOPE_LOCK(); (the clear ability functions check AbilityScopeLockCount internally to prevent removing abilities if the list is locked). GASDocumentation</p>"},{"location":"commonabilitysystemcomponent/#basic-requirements","title":"Basic Requirements","text":"<p>To set up your AActor subclass to use the Gameplay Ability System, implement the IAbilitySystemInterface interface and override the GetAbilitySystemComponent function. This function must return the Ability System Component associated with your Actor. In most cases, the Actor class will have a variable, tagged with UPROPERTY, that stores a pointer to the Ability System Component, similar to any built-in Component on any Actor type. While it is common for an Actor to have its own Ability System Component, there are cases in which you might want an Actor, such as a player's Pawn or Character, to use an Ability System Component owned by another Actor, like a Player State or Player Controller. Reasons for this may include things like a player's score, or long-lasting ability cooldown timers that do not reset when the player's Pawn or Character is destroyed and respawned, or when the player possesses a new Pawn or Character. The Gameplay Ability System supports this behavior; to implement it, write the Actor's GetAbilitySystemComponent function so that it returns the Ability System Component you want to use. Official Documentation</p>"},{"location":"commonabilitysystemcomponent/#so-what-does-abilitysystemcomponent-do-in-commongas","title":"So, What does AbilitySystemComponent do in CommonGAS?","text":"<p>Our ASC is mainly handling the initialization for the <code>CommonExtensionComponent</code> and relationship of <code>AbilityTagRelationshipMapping</code>.</p> <p>C++ API:</p> Name Functionality GetActiveAbilitiesWithTags Returns a list of currently active ability instances that match the tags GetAbilitySystemComponentFromActor Version of function in AbilitySystemGlobals that returns correct type AbilityInputTagPressed AbilityInputTagReleased ProcessAbilityInput ClearAbilityInput SetTagRelationshipMapping Sets the current tag relationship mapping, if null it will clear it out GetAdditionalActivationTagRequirements Looks at ability tags and gathers additional required and blocking tags"},{"location":"commonabilitysystemlibrary/","title":"CommonAbilitySystemLibrary","text":""},{"location":"commonabilitysystemlibrary/#getactiveabilitieswithtags","title":"GetActiveAbilitiesWithTags","text":"<p>Return a list of all active abilities with given ability tags container</p> <p></p> Name Types Ability Tags    (Input) Gameplay Tag Container Active Abilities (Output) An array of CommonGameplayAbility"},{"location":"commonabilitysystemlibrary/#getcooldownremainingtag","title":"GetCooldownRemainingTag","text":"<p>Returns total time and remaining time for cooldown tags. Returns false if no active cooldowns found</p> <p></p> Name Types Cooldown Tags    (Input) Gameplay Tag Container Time Remaining (Output) Float Cooldown Duration (Output) Float Return Value (Output) Boolean"},{"location":"commonabilitysystemlibrary/#activateabilitieswithtags","title":"ActivateAbilitiesWithTags","text":"<p>Attempts to activate all abilities that match the specified tags Returns true if it thinks it activated, but it may return false positives due to failure later in activation. If bAllowRemoteActivation is true, it will remotely activate local/server abilities, if false it will only try to locally activate the ability</p> <p></p> Name Types Ability Tags    (Input) Gameplay Tag Container Allow Remote Activation (Input) Boolean Return Value (Output) Boolean"},{"location":"commonabilitysystemlibrary/#grantability","title":"GrantAbility","text":"<p>Grant a gameplay ability to owner Abilitysystemcomponent\u2019s list of active abilities</p> <p></p> Name Types New Ability    (Input) Gameplay Ability class reference"},{"location":"commonabilitysystemlibrary/#removeability","title":"RemoveAbility","text":"<p>Remove a gameplay ability from owner Abilitysystemcomponent\u2019s list of active abilities</p> <p></p> Name Types Ability    (Input) Gameplay Ability class reference"},{"location":"commonabilitysystemlibrary/#doeseffectcontainerspechaveeffects","title":"DoesEffectContainerSpecHaveEffects","text":"Name Types Container Spec    (Input) CommonEffectContainerSpec Return Value    (Output) Boolean"},{"location":"commonabilitysystemlibrary/#cleareffectcontainerspectargets","title":"ClearEffectContainerSpecTargets","text":"Name Types Container Spec    (Input) CommonEffectContainerSpec reference"},{"location":"commonabilitysystemlibrary/#doeseffectcontainerspechavetargets","title":"DoesEffectContainerSpecHaveTargets","text":"Name Types Container Spec    (Input) CommonEffectContainerSpec reference Return Value    (Output) Boolean"},{"location":"commonabilitysystemlibrary/#addtargetstoeffectcontainerspec","title":"AddTargetsToEffectContainerSpec","text":"Name Types Container Spec    (Input) CommonEffectContainerSpec referenc Hit Results    (Input) An array of hit result reference Target Actors    (Input) An array of actor reference Return Value    (Output) CommonEffectContainerSpec"},{"location":"commonabilitysystemlibrary/#applyexternaleffectcontainerspec","title":"ApplyExternalEffectContainerSpec","text":"Name Types Container Spec    (Input) CommonEffectContainerSpec reference Return Value    (Output) An array of ActiveGameplayEffectHandle reference"},{"location":"commonabilitytagrelationshipmapping/","title":"Common Ability Tag Relationship Mapping","text":""},{"location":"commonabilitytagrelationshipmapping/#what-is-abilitytagrelationshipmapping","title":"What is AbilityTagRelationshipMapping?","text":"<p>UAbilityTagRelationshipMapping is a UDataAsset that managed mapping of how ability tags block or cancel other abilities. Without using AbilityTagRelationshipMapping, you have to make your own system by using and overriding UAbilitySystemComponent's </p> <pre><code>\nvirtual void ApplyAbilityBlockAndCancelTags(const FGameplayTagContainer&amp; AbilityTags, UGameplayAbility* RequestingAbility, bool bEnableBlockTags, const FGameplayTagContainer&amp; BlockTags, bool bExecuteCancelTags, const FGameplayTagContainer&amp; CancelTags) override;\n\n</code></pre> <p>and UGameplayAbility 's</p> <pre><code>\nvirtual bool DoesAbilitySatisfyTagRequirements(const UAbilitySystemComponent&amp; AbilitySystemComponent, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, FGameplayTagContainer* OptionalRelevantTags) const override;\n\n</code></pre>"},{"location":"commonabilitytagrelationshipmapping/#how-do-we-use-abilitytagrelationshipmapping-in-commongas","title":"How do we use AbilityTagRelationshipMapping in CommonGAS?","text":"<p>In CommonGAS, you have to make your own AbilityTagRelationshipMapping set and filling all of gameplay tag interactions required for you game</p> <p>To do this, you need to find <code>Miscellaneous-DataAsset</code> and choose <code>UCommonAbilityTagRelationshipMapping</code>. After that, you will be greet with this:</p> <p></p> <p>To apply this relationship, you need to find your <code>ACharacters-&gt;ACommonModularCharacter</code> blueprint character class CDO under <code>CommonGAS-&gt;Character-&gt;Abilities-&gt;AbilityTagRelationshipMapping</code> and add your relationship mapping.</p> <p></p>"},{"location":"commonabilitytagrelationshipmapping/#properties","title":"Properties","text":"Name Functionality AbilityTag The tag that this container relationship is about. Single tag, but abilities can have multiple of these AbilityTagsToBlock The other ability tags that will be blocked by any ability using this tag AbilityTagsToCancel The other ability tags that will be canceled by any ability using this tag ActivationRequiredTags If an ability has the tag, this is implicitly added to the activation required tags of the ability ActivationBlockedTags If an ability has the tag, this is implicitly added to the activation blocked tags of the ability"},{"location":"commonabilitytypes/","title":"Commonabilitytypes","text":"<p>test</p>"},{"location":"commonaniminstance/","title":"CommonAnimInstance","text":"<p>Gameplay Tag Blueprint Property Mapping is a special structure in GAS that can be used in Blueprints to \"bind\" specific properties. It watches an ASC for tag changes and automatically updates properties on another class.</p>"},{"location":"commonaniminstance/#properties","title":"Properties","text":"<p><code>FGameplayTagPropertyMapping</code></p> <p>The idea is simply that you can set a GameplayTag somewhere and then map it to a variable and then when you access the variable in your anim blueprint, it will match the tag. </p>"},{"location":"commonaniminstance/#how-does-it-work","title":"How Does It Work","text":"<ol> <li>Create an <code>animation blueprint</code> class with the parent of <code>CommonAnimInstance</code>.</li> <li> <p>Open your animbp class default and you should see <code>GameplayTags-&gt;GameplayTagPropertyMap-&gt;PropertiesMappings</code> </p> </li> <li> <p>Now, fill what gameplay tag you want to bind to a specific variable inside your anim bp.</p> </li> </ol> <p>Example:</p> <p></p> <p>Now, you should be good to go to manipulate the behaviour of that said variable to suit your need.</p>"},{"location":"commonattributeset/","title":"Common Attribute Set","text":"<p>General UAttributeSet to be subclassed and provide Health and Mana functionality</p> <p>Things like Death and Respawn will not be handle in this attributeset</p> <p><code>Note</code>: In the future, if there's a demand for such system, i will be using this AttributeSet as a base for OnDeath and OnRespawn for Respawning character</p> <p><code>UAttributeSet</code></p> <p>Explanation:</p> <p><code>Defines the set of all GameplayAttributes for your game Games should subclass this and add FGameplayAttributeData properties to represent attributes like health, damage, etc AttributeSets are added to the actors as subobjects, and then registered with the AbilitySystemComponent It often desired to have several sets per project that inherit from each other You could make a base health set, then have a player set that inherits from it and adds more attributes</code></p> Gameplay Attributes Functionality Health By default, the value of is capped by 50.f MaxHealth By default, the value of is capped by 100.f Mana By default, the value of is capped by 50.f MaxMana By default, the value of is capped by 100.f Damage This Damage is just used for applying negative health mods. Its not a 'persistent' attribute Healing This Healing is just used for applying positive health mods. Its not a 'persistent' attribute"},{"location":"commonattributesetbase/","title":"Commonattributesetbase","text":"<p>test</p>"},{"location":"commonenhancedinputcomponent/","title":"Commonenhancedinputcomponent","text":"<p>insert something here</p>"},{"location":"commonextensioncomponent/","title":"CommonExtensionComponent","text":"<p>Extension component that handle abilitysystemcomponet interaction for pawn/character This component will also handle initialization for ASC and provides useful Qol functions to be use</p>"},{"location":"commonextensioncomponent/#c-api","title":"C++ API","text":"Name Functionality AddLooseGameplayTag Allows GameCode to add loose gameplaytag which are not backed by a GameplayEffect RemoveLooseGameplayTag Allows GameCode to remove loose gameplaytag which are not backed by a GameplayEffect ActivateAbilitiesWithTags Attempts to activate all abilities that match the specified tags GetActiveAbilitiesWithTags Returns a list of active abilities matching the specified tags. This only returns if the ability is currently running GetCooldownRemainingForTag Returns total time and remaining time for cooldown tags. Returns false if no active cooldowns found GrantAbility Grant the specified ability on server ExecuteGameplayCueWithParams Invoke a one time \"instant\" execute event for a gameplay cue on the component owner. AddGameplayCueWithParams Invoke the added event for a gameplay cue on the component owner. RemoveGameplayCueWithParams Invoke the removed event for a gameplay cue on the component owner. ExecuteGameplayCueWithEffectContext Invoke a one time \"instant\" execute event for a gameplay cue on the component owner. AddGameplayCueWithEffectContext Invoke the added event for a gameplay cue on the component owner."},{"location":"commongameplayability/","title":"CommonGameplayAbility","text":""},{"location":"commongameplayability/#common-gameplay-ability","title":"Common Gameplay Ability","text":""},{"location":"commongameplayability/#class-defaults","title":"Class Defaults","text":"<p>Map of gameplay tags to gameplay effect containers and Boolean check if an ability to be granted on granted</p> <p></p> Name Types Effect Container Map An array of CommonEffectContainer reference Activate Ability On Granted Boolean"},{"location":"commongameplayability/#ongiveability","title":"OnGiveAbility","text":"<p>Called when the ability is given to an AbilitySystemComponent</p> <p></p>"},{"location":"commongameplayability/#onremoveability","title":"OnRemoveAbility","text":"<p>Called when the ability is removed from an AbilitySystemComponent </p> <p></p>"},{"location":"commongameplayability/#onavatarset","title":"OnAvatarSet","text":"<p>If an ability is marked as 'ActivateAbilityOnGranted', activate them immediately when given here</p> <p></p>"},{"location":"commongameplaycuefunctionlibrary/","title":"Commongameplaycuefunctionlibrary","text":"<p>insert something here</p>"},{"location":"commongameplayeffectlibrary/","title":"CommonGameplayEffectLibrary","text":""},{"location":"commongameplayeffectlibrary/#c-api","title":"C++ API","text":"Name Functionality"},{"location":"commongameplaytag/","title":"Common Gameplay Tags","text":""},{"location":"commongameplaytag/#what-is-native-gameplay-tag","title":"What is Native Gameplay Tag?","text":"<p>Native tag is a way for add/use Gameplay Tags inside C++  and Blueprint and there are many ways you can do this. Unreal Engine has a very nice base struct we can utilize for this purpose, and we can make our own derived struct to handle these tags and provide nice C++ accessors Source Code:</p> <pre><code>Holds a gameplay tag that was registered during static construction of the module, and will\nbe unregistered when the module unloads.  Each registration is based on the native tag pointer\nso even if two modules register the same tag and one is unloaded, the tag will still be registered\nby the other one.\n</code></pre>"},{"location":"commongameplaytag/#how-to-use-native-gameplay-tag","title":"How to Use Native Gameplay Tag?","text":"<p><code>NativeGameplayTag.h</code> provides these useful definitions:</p> <pre><code>namespace UE::GameplayTags::Private\n{\n    // Used to prevent people from putting UE_DEFINE_GAMEPLAY_TAG_STATIC and UE_DEFINE_GAMEPLAY_TAG in their headers.\n    constexpr bool HasFileExtension(const char* File)\n    {\n        const char* It = File;\n        while (*It)\n            ++It;\n        return It[-1] == 'p' &amp;&amp; It[-2] == 'p' &amp;&amp; It[-3] == 'c' &amp;&amp; It[-4] == '.';\n    }\n}\n</code></pre> <pre><code>/**\n * Declares a native gameplay tag that is defined in a cpp with UE_DEFINE_GAMEPLAY_TAG to allow other modules or code to use the created tag variable.\n */\n#define UE_DECLARE_GAMEPLAY_TAG_EXTERN(TagName) extern FNativeGameplayTag TagName;\n\n</code></pre> <pre><code>/**\n * Defines a native gameplay tag with a comment that is externally declared in a header to allow other modules or code to use the created tag variable.\n */\n#define UE_DEFINE_GAMEPLAY_TAG_COMMENT(TagName, Tag, Comment) FNativeGameplayTag TagName(UE_PLUGIN_NAME, UE_MODULE_NAME, Tag, TEXT(Comment), ENativeGameplayTagToken::PRIVATE_USE_MACRO_INSTEAD); static_assert(UE::GameplayTags::Private::HasFileExtension(__FILE__), \"UE_DEFINE_GAMEPLAY_TAG_COMMENT can only be used in .cpp files, if you're trying to share tags across modules, use UE_DECLARE_GAMEPLAY_TAG_EXTERN in the public header, and UE_DEFINE_GAMEPLAY_TAG_COMMENT in the private .cpp\");\n</code></pre> <pre><code>/**\n * Defines a native gameplay tag with no comment that is externally declared in a header to allow other modules or code to use the created tag variable.\n */\n#define UE_DEFINE_GAMEPLAY_TAG(TagName, Tag) FNativeGameplayTag TagName(UE_PLUGIN_NAME, UE_MODULE_NAME, Tag, TEXT(\"\"), ENativeGameplayTagToken::PRIVATE_USE_MACRO_INSTEAD); static_assert(UE::GameplayTags::Private::HasFileExtension(__FILE__), \"UE_DEFINE_GAMEPLAY_TAG can only be used in .cpp files, if you're trying to share tags across modules, use UE_DECLARE_GAMEPLAY_TAG_EXTERN in the public header, and UE_DEFINE_GAMEPLAY_TAG in the private .cpp\");\n</code></pre> <pre><code>/**\n * Defines a native gameplay tag such that it's only available to the cpp file you define it in.\n */\n#define UE_DEFINE_GAMEPLAY_TAG_STATIC(TagName, Tag) static FNativeGameplayTag TagName(UE_PLUGIN_NAME, UE_MODULE_NAME, Tag, TEXT(\"\"), ENativeGameplayTagToken::PRIVATE_USE_MACRO_INSTEAD); static_assert(UE::GameplayTags::Private::HasFileExtension(__FILE__), \"UE_DEFINE_GAMEPLAY_TAG_STATIC can only be used in .cpp files, if you're trying to share tags across modules, use UE_DECLARE_GAMEPLAY_TAG_EXTERN in the public header, and UE_DEFINE_GAMEPLAY_TAG in the private .cpp\");\n\n</code></pre> <p>First, you need to add <code>Abilities/CommonGameplayTags.h</code> in your include. There a two ways to use this, </p> <ol> <li> <p>The first way is by using <code>UE::GameplayTags::Private</code>. Using the namespace way, you dont have to declare and putting <code>UE_DEFINE_GAMEPLAY_TAG_STATIC</code> and <code>UE_DEFINE_GAMEPLAY_TAG</code> in the header. In the future, we will use this namespace way of using native gameplay tag instead of the struct way as to it is way convenient.</p> </li> <li> <p>The second way is using <code>UE_DEFINE_GAMEPLAY_TAG_STATIC</code> and <code>UE_DEFINE_GAMEPLAY_TAG</code>.</p> </li> </ol> <p><code>UE_DEFINE_GAMEPLAY_TAG_STATIC</code> is only to be use inside .cpp files and can only be use in that file. In my game, i use this static tag for defining movement blocking tag inside my UGameplayAbility class and my UCharacterMovementComponent class to block any movement related abilities.</p> <p>Code:</p> <pre><code>UE_DEFINE_GAMEPLAY_TAG_STATIC(Static_Movement_Blocked, \"Ability.Movement.Blocked\");\n\nUOuranosGameplayAbility::UOuranosGameplayAbility()\n{\n    ActivationBlockedTags.AddTag(Static_Movement_Blocked);\n}\n</code></pre> <p>For <code>UE_DEFINE_GAMEPLAY_TAG</code>, you have to declare it in both header and cpp file. In CommonGAS, we use this for the built-in relationship blocking and canceling system of the AbilityTagRelationshipMaspping</p> <p>You need to declare <code>UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_AbilityInputBlocked);</code> in you header file:</p> <p></p> <p>Then, you need to declare <code>UE_DEFINE_GAMEPLAY_TAG(TAG_Gameplay_AbilityInputBlocked, \"Gameplay.AbilityInputBlocked\");</code> in you cpp file:</p> <p></p> <p>Usage:</p> <p></p> <p>so, thats how we can use native tag. Right now, CommonGAS is using struct way of using native tag but in the future, we will moving to using namespace way of using native tag. :)</p>"},{"location":"commongameplaytaglibrary/","title":"CommonGameplayTagLibrary","text":"<p>The purpose of this library is to provide gameplay tag operation outside of using <code>CommonExtensionComponent</code> or be used by AI-controlled characters</p>"},{"location":"commongameplaytaglibrary/#c-api","title":"C++ API","text":"Name Functionality AddLooseGameplayTag Manually adds a set of tags to a given actor, and optionally replicates them RemoveLooseGameplayTag Manually removes a set of tags from a given actor, with optional replication DoesActorHasMatchingGameplayTag DoesActorHasAllMatchingGameplayTags DoesActorHasAnyMatchingGameplayTags GetActorOwnedGameplayTags"},{"location":"commoninputconfig/","title":"Commoninputconfig","text":"<p>insert something here</p>"},{"location":"commonmodmagnitudecalculation/","title":"CommonModMagnitudeCalculation","text":""},{"location":"commonmodmagnitudecalculation/#what-is-modmagnitudecalculation","title":"What is ModMagnitudeCalculation","text":"<p>ModifierMagnitudeCalculations (ModMagCalc or MMC) are powerful classes used as Modifiers in GameplayEffects. They function similarly to GameplayEffectExecutionCalculations but are less powerful and most importantly they can be predicted. Their sole purpose is to return a float value from CalculateBaseMagnitude_Implementation(). You can subclass and override this function in Blueprint and C++.</p> <p>MMCs can be used in any duration of GameplayEffects - Instant, Duration, Infinite, or Periodic.</p> <p>MMCs' strength lies in their capability to capture the value of any number of Attributes on the Source or the Target of GameplayEffect with full access to the GameplayEffectSpec to read GameplayTags and SetByCallers. Attributes can either be snapshotted or not. Snapshotted Attributes are captured when the GameplayEffectSpec is created whereas non snapshotted Attributes are captured when the GameplayEffectSpec is applied and automatically update when the Attribute changes for Infinite and Duration GameplayEffects. Capturing Attributes recalculates their CurrentValue from existing mods on the ASC. This recalculation will not run PreAttributeChange() in the AbilitySet so any clamping must be done here again.</p> Snapshot Source or Target Captured on GameplayEffectSpec Automatically updates when Attribute changes for Infinite or Duration GE Yes Source Creation No Yes Target Application No No Source Application Yes No Target Application Yes <p>The resultant float from an MMC can further be modified in the GameplayEffect's Modifier by a coefficient and a pre and post coefficient addition.</p> <p>An example MMC that captures the Target's mana Attribute reduces it from a poison effect where the amount reduced changes depending on how much mana the Target has and a tag that the Target might have:</p> <pre><code>\nUPAMMC_PoisonMana::UPAMMC_PoisonMana()\n{\n\n    //ManaDef defined in header FGameplayEffectAttributeCaptureDefinition ManaDef;\n    ManaDef.AttributeToCapture = UPAAttributeSetBase::GetManaAttribute();\n    ManaDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;\n    ManaDef.bSnapshot = false;\n\n    //MaxManaDef defined in header FGameplayEffectAttributeCaptureDefinition MaxManaDef;\n    MaxManaDef.AttributeToCapture = UPAAttributeSetBase::GetMaxManaAttribute();\n    MaxManaDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;\n    MaxManaDef.bSnapshot = false;\n\n    RelevantAttributesToCapture.Add(ManaDef);\n    RelevantAttributesToCapture.Add(MaxManaDef);\n}\n\nfloat UPAMMC_PoisonMana::CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec &amp; Spec) const\n{\n    // Gather the tags from the source and target as that can affect which buffs should be used\n    const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags();\n    const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags();\n\n    FAggregatorEvaluateParameters EvaluationParameters;\n    EvaluationParameters.SourceTags = SourceTags;\n    EvaluationParameters.TargetTags = TargetTags;\n\n    float Mana = 0.f;\n    GetCapturedAttributeMagnitude(ManaDef, Spec, EvaluationParameters, Mana);\n    Mana = FMath::Max&lt;float&gt;(Mana, 0.0f);\n\n    float MaxMana = 0.f;\n    GetCapturedAttributeMagnitude(MaxManaDef, Spec, EvaluationParameters, MaxMana);\n    MaxMana = FMath::Max&lt;float&gt;(MaxMana, 1.0f); // Avoid divide by zero\n\n    float Reduction = -20.0f;\n    if (Mana / MaxMana &gt; 0.5f)\n    {\n        // Double the effect if the target has more than half their mana\n        Reduction *= 2;\n    }\n\n    if (TargetTags-&gt;HasTagExact(FGameplayTag::RequestGameplayTag(FName(\"Status.WeakToPoisonMana\"))))\n    {\n        // Double the effect if the target is weak to PoisonMana\n        Reduction *= 2;\n    }\n\n    return Reduction;\n}\n\n</code></pre> <p>If you don't add the FGameplayEffectAttributeCaptureDefinition to RelevantAttributesToCapture in the MMC's constructor and try to capture Attributes, you will get an error about a missing Spec while capturing. If you don't need to capture Attributes, then you don't have to add anything to RelevantAttributesToCapture.</p> <p>GASDocumentation</p> <p>Note:</p> <pre><code>Currently this class is being use with Common Pre_ and Sub_ prefix is because in default MMC, Epic\nmade a mistake of not making all BlueprintCallable functions const so this class is being use for that\n\n(This will be remove in the future once Epic fix that issue)\n</code></pre>"},{"location":"commonmodmagnitudecalculation/#cblueprint-api","title":"C++/Blueprint API","text":""},{"location":"commonmodmagnitudecalculation/#getcapturedattributemagnitude","title":"GetCapturedAttributeMagnitude``","text":"<p>Gets the captured magnitude value for the given Attribute</p> <p>For this to work correctly, the Attribute needs to be added to the Relevant Attributes to Capture array</p> <p>C++:</p> <p><code>K2_CommonGetCapturedAttributeMagnitude</code></p> <p>Blueprint:</p> <p><code>CommonGetCapturedAttributeMagnitude</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Attribute (Input) The attribute to query Return Value (Output) The magnitude value if found, zero otherwise"},{"location":"commonmodmagnitudecalculation/#getsetbycallermagnitudebytag","title":"GetSetByCallerMagnitudeByTag","text":"<p>Extracts the Set by Caller Magnitude from a Gameplay Effect Spec</p> <p>C++:</p> <p><code>CommonGetSetByCallerMagnitudeByTag</code></p> <p>Blueprint:</p> <p><code>CommonGetSetByCallerMagnitudeByTag</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Tag (Input) The effect tag to query Return Value (Output) The magnitude value if found, zero"},{"location":"commonmodmagnitudecalculation/#commongetsetbycallermagnitudebyname","title":"CommonGetSetByCallerMagnitudeByName","text":"<p>Extracts the Set by Caller Magnitude from a Gameplay Effect Spec</p> <p>C++:</p> <p><code>CommonGetSetByCallerMagnitudeByName</code></p> <p>Blueprint:</p> <p><code>CommonGetSetByCallerMagnitudeByName</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from MagnitudeName (Input) The effect name to query Return Value (Output) The magnitude value if found, zero"},{"location":"commonmodmagnitudecalculation/#commongetsourceaggregatedtags","title":"CommonGetSourceAggregatedTags","text":"<p>Copies and returns the source aggregated tags from a Gameplay Effect Spec C++:</p> <p><code>CommonGetSourceAggregatedTags</code></p> <p>Blueprint:</p> <p><code>CommonGetSourceAggregatedTags</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Return Value (Output) Gameplay Tag Container with the copied tags. The container will be empty if no captured source tags exist"},{"location":"commonmodmagnitudecalculation/#commongetsourceactortags","title":"CommonGetSourceActorTags","text":"<p>Returns the source actor tags from a Gameplay Effect Spec</p> <p>C++:</p> <p><code>CommonGetSourceActorTags</code></p> <p>Blueprint:</p> <p><code>CommonGetSourceActorTags</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Return Value (Output) Gameplay Tag Container with the copied tags. The container will be empty if no captured source tags exist."},{"location":"commonmodmagnitudecalculation/#commongettargetaggregatedtags","title":"CommonGetTargetAggregatedTags","text":"<p>Copies and returns the target aggregated tags from a Gameplay Effect Spec</p> <p>C++:</p> <p><code>CommonGetTargetAggregatedTags</code></p> <p>Blueprint:</p> <p><code>CommonGetTargetAggregatedTags</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Return Value (Output) Gameplay Tag Container with the copied tags. The container will be empty if no captured source tags exist."},{"location":"commonmodmagnitudecalculation/#commongettargetactortags","title":"CommonGetTargetActorTags","text":"<p>Returns the target actor tags from a Gameplay Effect Spec Useful for Modifier Magnitude Calculations</p> <p>C++:</p> <p><code>CommonGetTargetActorTags</code></p> <p>Blueprint:</p> <p><code>CommonGetTargetActorTags</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Return Value (Output) Gameplay Tag Container with the copied tags. The container will be empty if no captured source tags exist."},{"location":"commonmodmagnitudecalculation/#commongettargetspectags","title":"CommonGetTargetSpecTags","text":"<p>Returns the target spec tags from a Gameplay Effect Spec Useful for Modifier Magnitude Calculations</p> <p>C++:</p> <p><code>CommonGetTargetSpecTags</code></p> <p>Blueprint:</p> <p><code>CommonGetTargetSpecTags</code></p> <p></p> Name Functionality EffectSpec (Input) The Gameplay Effect Spec to get the info from Return Value (Output) Gameplay Tag Container with the copied tags. The container will be empty if no captured source tags exist."},{"location":"commonmodmagnitudecalculation/#fgameplayeffectspec","title":"FGameplayEffectSpec","text":"<p>Tells us:</p> <ul> <li>What UGameplayEffect (const data)</li> <li>What Level</li> <li>Who instigated</li> </ul> <p>Note:</p> <p><code>I exposed this functionality just so designer can have these functions if they want some speficic modification be done in blueprint but i recommend use FGameplayEffectSpec functions for calculations and modifications in c++ for better control.</code></p> <p><code>Its very rarely you need to use some of these functions in blueprint but i exposed them if you ever needed to</code></p>"},{"location":"commonmodmagnitudecalculation/#hasvalidcapturedattributes","title":"HasValidCapturedAttributes","text":"<p>Determines if the spec has capture specs with valid captures for all of the specified definitions.</p> <p>C++:</p> <p><code>HasValidCapturedAttributes</code></p> <p>Blueprint:</p> <p><code>HasValidCapturedAttributes</code></p> <p></p> Name Functionality InCaptureDefsToCheck (Input) Capture definitions to check for Return Value (Output) True if the container has valid capture attributes for all of the specified definitions, false if it does not"},{"location":"commonmodmagnitudecalculation/#attemptcalculatedurationfromdef","title":"AttemptCalculateDurationFromDef","text":"<p>Helper function to attempt to calculate the duration of the spec from its GE definition</p> <p>C++:</p> <p><code>AttemptCalculateDurationFromDef</code></p> <p>Blueprint:</p> <p><code>AttemptCalculateDurationFromDef</code></p> <p></p> Name Functionality OutDefDuration (Input) Computed duration of the spec from its GE definition; Not the actual duration of the spec Return Value (Output) True if the container has valid capture attributes for all of the specified definitions, false if it does not"},{"location":"commonmodmagnitudecalculation/#getspecduration","title":"GetSpecDuration","text":"<p>C++:</p> <p><code>GetSpecDuration</code></p> <p>Blueprint:</p> <p><code>GetSpecDuration</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) Float"},{"location":"commonmodmagnitudecalculation/#getspecperiod","title":"GetSpecPeriod","text":"<p>C++:</p> <p><code>GetSpecPeriod</code></p> <p>Blueprint:</p> <p><code>GetSpecPeriod</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) Float"},{"location":"commonmodmagnitudecalculation/#getspecchancetoapplytotarget","title":"GetSpecChanceToApplyToTarget","text":"<p>C++:</p> <p><code>GetSpecChanceToApplyToTarget</code></p> <p>Blueprint:</p> <p><code>GetSpecChanceToApplyToTarget</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) Float"},{"location":"commonmodmagnitudecalculation/#getspecallgrantedtags","title":"GetSpecAllGrantedTags","text":"<p>C++:</p> <p><code>GetSpecAllGrantedTags</code></p> <p>Blueprint:</p> <p><code>GetSpecAllGrantedTags</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) FGameplayEffectContainer"},{"location":"commonmodmagnitudecalculation/#getspecallblockedabilitytags","title":"GetSpecAllBlockedAbilityTags","text":"<p>C++:</p> <p><code>GetSpecAllBlockedAbilityTags</code></p> <p>Blueprint:</p> <p><code>GetSpecAllBlockedAbilityTags</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) FGameplayEffectContainer"},{"location":"commonmodmagnitudecalculation/#getspecallassettags","title":"GetSpecAllAssetTags","text":"<p>C++:</p> <p><code>GetSpecAllAssetTags</code></p> <p>Blueprint:</p> <p><code>GetSpecAllAssetTags</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) FGameplayEffectContainer"},{"location":"commonmodmagnitudecalculation/#getspeclevel","title":"GetSpecLevel","text":"<p>C++:</p> <p><code>GetSpecLevel</code></p> <p>Blueprint:</p> <p><code>GetSpecLevel</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) float"},{"location":"commonmodmagnitudecalculation/#capturespecattributedatafromtarget","title":"CaptureSpecAttributeDataFromTarget","text":"<p>C++:</p> <p><code>CaptureSpecAttributeDataFromTarget</code></p> <p>Blueprint:</p> <p><code>CaptureSpecAttributeDataFromTarget</code></p> <p></p> Name Functionality Target AbilitySystemComponent (Input) UAbilitySystemComponent Return Value (Output) FGameplayEffectSpec"},{"location":"commonmodmagnitudecalculation/#getspecmodifiermagnitude","title":"GetSpecModifierMagnitude","text":"<p>Get the computed magnitude of the modifier on the spec with the specified index</p> <p>C++:</p> <p><code>GetSpecModifierMagnitude</code></p> <p>Blueprint:</p> <p><code>GetSpecModifierMagnitude</code></p> <p></p> Name Functionality ModifierIndx (Input) Modifier to get bFactorInStackCount (Input) If true, the calculation will include the stack count Return Value (Output) Computed magnitude"},{"location":"commonmodmagnitudecalculation/#recapturespecsourceactortags","title":"RecaptureSpecSourceActorTags","text":"<p>Recaptures source actor tags of this spec without modifying anything else</p> <p>C++:</p> <p><code>RecaptureSpecSourceActorTags</code></p> <p>Blueprint:</p> <p><code>RecaptureSpecSourceActorTags</code></p> <p></p> Name Functionality Return Value (Output) FGameplayEffectSpec"},{"location":"commonmodmagnitudecalculation/#setupspecattributecapturedefinitions","title":"SetupSpecAttributeCaptureDefinitions","text":"<p>Helper function to initialize all of the capture definitions required by the spec</p> <p>C++:</p> <p><code>SetupSpecAttributeCaptureDefinitions</code></p> <p>Blueprint:</p> <p><code>SetupSpecAttributeCaptureDefinitions</code></p> <p></p> Name Functionality Return Value (Output) FGameplayEffectSpec"},{"location":"commonmodmagnitudecalculation/#calculatespecmodifiedduration","title":"CalculateSpecModifiedDuration","text":"<p>Helper function that returns the duration after applying relevant modifiers from the source and target ability system components</p> <p>C++:</p> <p><code>CalculateSpecModifiedDuration</code></p> <p>Blueprint:</p> <p><code>CalculateSpecModifiedDuration</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) Float"},{"location":"commonmodmagnitudecalculation/#adddynamicassettag","title":"AddDynamicAssetTag","text":"<p>Dynamically add an asset tag not originally from the source GE definition; Added to DynamicAssetTags as well as injected into the captured source spec tags</p> <p>C++:</p> <p><code>AddDynamicAssetTag</code></p> <p>Blueprint:</p> <p><code>AddDynamicAssetTag</code></p> <p></p> Name Functionality TagToAdd (Input) FGameplayTag Return Value (Output) FGameplayEffectSpec"},{"location":"commonmodmagnitudecalculation/#appenddynamicassettags","title":"AppendDynamicAssetTags","text":"<p>Dynamically append asset tags not originally from the source GE definition; Added to DynamicAssetTags as well as injected into the captured source spec tags</p> <p>C++:</p> <p><code>AppendDynamicAssetTags</code></p> <p>Blueprint:</p> <p><code>AppendDynamicAssetTags</code></p> <p></p> Name Functionality TagToAppend (Input) FGameplayTagContainer Return Value (Output) FGameplayEffectSpec"},{"location":"commonmodmagnitudecalculation/#getdynamicassettags","title":"GetDynamicAssetTags","text":"<p>C++:</p> <p><code>GetDynamicAssetTags</code></p> <p>Blueprint:</p> <p><code>GetDynamicAssetTags</code></p> <p></p> Name Functionality Spec (Input) FGameplayEffectSpec Return Value (Output) FGameplayTagContainer"},{"location":"commonmodularactor/","title":"Common Modular Actor","text":"<p>Minimal class that supports extension by game feature plugins</p> <p>This class is intended to be used by AActors with AbilitySystemComponent living in this class for general gameplay uses</p>"},{"location":"commonmodularactor/#class-defaults","title":"Class Defaults","text":""},{"location":"commonmodularactor/#abilitysets","title":"AbilitySets","text":"<p>An array of UCommonAbilitySet data asset with functionality meant to be applied on startup to ACharacters</p> <p>Non-mutable data asset used to grant gameplay abilities and gameplay effects.</p> <p></p> Name Functionality Granted Gameplay Abilities Gameplay abilities to grant when this ability set is granted. Granted Gameplay Effects Gameplay effects to grant when this ability set is granted. Granted Attributes Attribute sets to grant when this ability set is granted.o be applied on startup"},{"location":"commonmodularactor/#ability-tag-relatipship","title":"Ability Tag Relatipship","text":"<p>An array of UAbilityRelationshipMapping data asset with functionality meant to be applied on startup to ACharacters</p> <p>Mapping of how ability tags block or cancel other abilities</p> <p></p> Name Functionality AbilityTag The tag that this container relationship is about. Single tag, but abilities can have multiple of these AbilityTagsToBlock The other ability tags that will be blocked by any ability using this tag AbilityTagsToCancel The other ability tags that will be canceled by any ability using this tag ActivationRequiredTags If an ability has the tag, this is implicitly added to the activation required tags of the ability ActivationBlockedTags If an ability has the tag, this is implicitly added to the activation blocked tags of the ability"},{"location":"commonmodularactor/#abilitysystemcomponent","title":"AbilitySystemComponent","text":"<p>Type: <code>UCommonAbilitySystemComponent</code></p>"},{"location":"commonmodularactor/#replicationmode","title":"ReplicationMode","text":"<p>Type: <code>EGameplayEffectReplicationMode</code></p> <p>How gameplay effects will be replicated to clients </p> Name Functionality Minimal Only replicate minimal gameplay effect info. Note: this does not work for Owned AbilitySystemComponents (Use Mixed instead). Mixed Only replicate minimal gameplay effect info to simulated proxies but full info to owners and autonomous proxies Full Replicate full gameplay info to all"},{"location":"commonmodularaicontroller/","title":"Common Modular AI Controller","text":"<p>Minimal class that supports extension by game feature plugins</p> <p>This class is intended to use with either <code>AAIPawn</code> and <code>AAIPawnWithStateTree</code> derived from <code>UCommonModularPawn</code> class to build AI-Controlled characters</p>"},{"location":"commonmodularcharacter/","title":"Common Modular Character","text":""},{"location":"commonmodularcharacter/#common-modular-character","title":"Common Modular Character","text":"<p>Minimal class that supports extension by game feature plugins</p> <p>This class is intended to be used by Player-Controlled actors with AbilitySystemComponent living in the PlayerState</p>"},{"location":"commonmodularcharacter/#class-properties","title":"Class Properties","text":""},{"location":"commonmodularcharacter/#abilitysets","title":"AbilitySets","text":"<p>An array of UCommonAbilitySet data asset with functionality meant to be applied on startup to ACharacters</p> <p>Non-mutable data asset used to grant gameplay abilities and gameplay effects.</p> <p></p> Name Functionality Granted Gameplay Abilities Gameplay abilities to grant when this ability set is granted. Granted Gameplay Effects Gameplay effects to grant when this ability set is granted. Granted Attributes Attribute sets to grant when this ability set is granted.o be applied on startup"},{"location":"commonmodularcharacter/#ability-tag-relatipship","title":"Ability Tag Relatipship","text":"<p>An array of UAbilityRelationshipMapping data asset with functionality meant to be applied on startup to ACharacters</p> <p>Mapping of how ability tags block or cancel other abilities</p> <p></p> Name Functionality AbilityTag The tag that this container relationship is about. Single tag, but abilities can have multiple of these AbilityTagsToBlock The other ability tags that will be blocked by any ability using this tag AbilityTagsToCancel The other ability tags that will be canceled by any ability using this tag ActivationRequiredTags If an ability has the tag, this is implicitly added to the activation required tags of the ability ActivationBlockedTags If an ability has the tag, this is implicitly added to the activation blocked tags of the ability"},{"location":"commonmodularcharacter/#abilitysystemcomponent","title":"AbilitySystemComponent","text":"<p>Type: <code>UCommonAbilitySystemComponent</code></p>"},{"location":"commonmodularcharacter/#replicationmode","title":"ReplicationMode","text":"<p>Type: <code>EGameplayEffectReplicationMode</code></p> <p>Enabled: <code>Mixed</code></p> <p>How gameplay effects will be replicated to clients </p> Name Functionality Minimal Only replicate minimal gameplay effect info. Note: this does not work for Owned AbilitySystemComponents (Use Mixed instead). Mixed Only replicate minimal gameplay effect info to simulated proxies but full info to owners and autonomous proxies Full Replicate full gameplay info to all"},{"location":"commonmodulargamemode/","title":"Commonmodulargamemode","text":""},{"location":"commonmodulargamemode/#acommonmodulargamemodebase","title":"ACommonModularGameModeBase","text":"<p>Pair this with a CommonModularGameStateBase</p>"},{"location":"commonmodulargamemode/#acommonmodulargamemode","title":"ACommonModularGameMode","text":"<p>Pair this with a CommonModularGameState</p>"},{"location":"commonmodulargamestate/","title":"Common Modular Game State","text":""},{"location":"commonmodulargamestate/#common-modular-game-state","title":"Common Modular Game State","text":""},{"location":"commonmodulargamestate/#class-defaults","title":"Class Defaults","text":""},{"location":"commonmodularpawn/","title":"Common Modular Pawn","text":"<p>Minimal class that supports extension by game feature plugins</p> <p>This class is intended to be used by AI-Controlled actors with AbilitySystemComponent living in this class</p>"},{"location":"commonmodularpawn/#class-defaults","title":"Class Defaults","text":""},{"location":"commonmodularpawn/#abilitysets","title":"AbilitySets","text":"<p>An array of UCommonAbilitySet data asset with functionality meant to be applied on startup to ACharacters</p> <p>Non-mutable data asset used to grant gameplay abilities and gameplay effects.</p> <p></p> Name Functionality Granted Gameplay Abilities Gameplay abilities to grant when this ability set is granted. Granted Gameplay Effects Gameplay effects to grant when this ability set is granted. Granted Attributes Attribute sets to grant when this ability set is granted.o be applied on startup"},{"location":"commonmodularpawn/#ability-tag-relatipship","title":"Ability Tag Relatipship","text":"<p>An array of UAbilityRelationshipMapping data asset with functionality meant to be applied on startup to ACharacters</p> <p>Mapping of how ability tags block or cancel other abilities</p> <p></p> Name Functionality AbilityTag The tag that this container relationship is about. Single tag, but abilities can have multiple of these AbilityTagsToBlock The other ability tags that will be blocked by any ability using this tag AbilityTagsToCancel The other ability tags that will be canceled by any ability using this tag ActivationRequiredTags If an ability has the tag, this is implicitly added to the activation required tags of the ability ActivationBlockedTags If an ability has the tag, this is implicitly added to the activation blocked tags of the ability"},{"location":"commonmodularpawn/#abilitysystemcomponent","title":"AbilitySystemComponent","text":"<p>Type: <code>UCommonAbilitySystemComponent</code></p>"},{"location":"commonmodularpawn/#replicationmode","title":"ReplicationMode","text":"<p>Type: <code>EGameplayEffectReplicationMode</code></p> <p>Enabled: <code>Minimal</code></p> <p>How gameplay effects will be replicated to clients </p> Name Functionality Minimal Only replicate minimal gameplay effect info. Note: this does not work for Owned AbilitySystemComponents (Use Mixed instead). Mixed Only replicate minimal gameplay effect info to simulated proxies but full info to owners and autonomous proxies Full Replicate full gameplay info to all"},{"location":"commonmodularplayercontroller/","title":"Common Modular Player Controller","text":"<p>Minimal class that supports extension by game feature plugins</p> <p>This class is meant to be use with <code>UCommonModularCharacter</code></p>"},{"location":"commonmodularplayercontroller/#c-api","title":"C++ API","text":"Name Functionality GetCommonPlayerState Getter to get CommonPlayerState GetCommonAbilitySystemComponent Getter to get CommonAbilitySystemComponent"},{"location":"commonmodularplayerstate/","title":"Common Modular PlayerState","text":"<p>Minimal class that supports extension by game feature plugins</p> <p>This class is meant to be use with <code>UCommonModularCharacter</code> with ASC living in PlayerSate</p>"},{"location":"commonmodularplayerstate/#c-api","title":"C++ API","text":"Name Functionality GetCommonAbilitySystemComponent Getter to get CommonAbilitySystemComponent"},{"location":"commonmodularplayerstate/#abilitysystemcomponent","title":"AbilitySystemComponent","text":"<p>Type: <code>UCommonAbilitySystemComponent</code></p>"},{"location":"commonmodularplayerstate/#replicationmode","title":"ReplicationMode","text":"<p>Type: <code>EGameplayEffectReplicationMode</code></p> <p>Enabled : <code>Mixed</code></p> <p>How gameplay effects will be replicated to clients </p> Name Functionality Minimal Only replicate minimal gameplay effect info. Note: this does not work for Owned AbilitySystemComponents (Use Mixed instead). Mixed Only replicate minimal gameplay effect info to simulated proxies but full info to owners and autonomous proxies Full Replicate full gameplay info to all"},{"location":"commonplayercontrolscomponent/","title":"Commonplayercontrolscomponent","text":"<p>insert something here</p>"},{"location":"commontargettype/","title":"Commontargettype","text":"<p>test</p>"},{"location":"consolecommands/","title":"Console Commands","text":"<p>By default, GAS comes with useful console commands you can use to debug your gameplay</p>"},{"location":"consolecommands/#showdebug-abilitysystem","title":"showdebug abilitysystem","text":"<p><code>showdebug abilitysystem</code> mainly use for opening and closing the gameplay debugger in runtime</p>"},{"location":"consolecommands/#abilitysystemdebug","title":"AbilitySystem.Debug","text":"<p><code>AbilitySystem.Debug.NextCategory</code></p> <p><code>AbilitySystem.Debug.NextCategory</code> cycles betwen pages of GAS debugger</p> <ol> <li> <p>The first page shows the <code>CurrentValue</code> of all of your Attributes:  </p> </li> <li> <p>The second page shows all of the <code>Duration</code> and <code>Infinite GameplayEffects</code> on you, their number of stacks, what <code>GameplayTags</code> they give, and what <code>Modifiers</code> they give.  </p> </li> <li> <p>The third page shows all of the GameplayAbilities that have been granted to you, whether they are currently running, whether they are blocked from activating, and the status of currently running AbilityTasks.  </p> </li> </ol> <p><code>AbilitySystem.Debug.NextTarget / AbilitySystem.Debug.PrevTarget</code></p> <p><code>AbilitySystem.Debug.NextTarget / AbilitySystem.Debug.PrevTarget</code>allow you to debug all available <code>AbilitySystemComponent</code> in the world and switch to the <code>next</code> or <code>previous</code> target of said ASC</p> <p>GASDocumentation</p>"},{"location":"gamefeatureaction_addabilities/","title":"GameFeatureAction_AddAbilities","text":"<p>GameFeatureAction <code>Add Abilities</code>responsibles for granting abilities and gameplay effects to actors of a specified type when a game feature is enabled and removing abilities and gameplay effects when a game features is disabled.</p> <p></p> <p></p> Name Functionality Granted Abilities Applying a gameplay ability with an input action to apply with specified actor Granted Attribute Applying a attribute set with an data table to initialize gameplay attributes with specified actor"},{"location":"gamefeatureaction_addabilities/#granted-abilities","title":"Granted Abilities","text":"Name Functionality Ability Type UGameplayAbility to apply Input Action UInputAction to apply"},{"location":"gamefeatureaction_addabilities/#granted-attributes","title":"Granted Attributes","text":"Name Functionality Attribute Set Type UAttributeSet to grant Initialization Data Data table reference to initialize attributes with"},{"location":"gamefeatureaction_addinputcontextmapping/","title":"GameFeatureAction_AddInputContextMapping","text":"<p><code>AddInputMappingContext</code> adds <code>InputMappingContext</code> to local players' EnhancedInput system when a game feature is enabled and remove <code>InputMappingContext</code> when a game feature is disabled. </p> <p><code>AddInputMappingContext</code> also work in tandem with <code>Add Abilities</code> game feature action when an Ability is granted alongside an Input Action</p> <p></p> Name Functionality Input Mapping Input Mapping Context to apply Priority Higher priority InputMappingContext will be prioritized instead of lower priority Input Mapping Context"},{"location":"gamefeatureaction_addworldsystem/","title":"Gamefeatureaction addworldsystem","text":"<p>insert something here</p>"},{"location":"gamefeatureaction_worldactionbase/","title":"Gamefeatureaction worldactionbase","text":"<p>insert something here</p>"},{"location":"gameplaymessageprocessor/","title":"GameplayMessageProcessor","text":"<p>insert something here</p>"},{"location":"gameplaymessagerouter/","title":"GameplayMessageRouter","text":"<p>insert something here</p>"},{"location":"gameplaymessagesubsystem/","title":"GameplayMessageSubsystem","text":"<p>insert something here</p>"},{"location":"gameplaymessagetypes2/","title":"GameplayMessageTypes2","text":"<p>insert something here</p>"},{"location":"howtoabilitytask/","title":"How-to AbilityTask","text":""},{"location":"howtoabilitytask/#what-is-a-ability-task","title":"What is a Ability Task?","text":"<p>Ability Tasks (C++ class UAbilityTask) are a specialized form of the more general Gameplay Task class intended to work with Gameplay Abilities. Games that use the Gameplay Ability System usually include a variety of custom Ability Tasks which implement their unique gameplay features. They perform asynchronous work during a Gameplay Ability's execution, and have the capability to affect execution flow by calling Delegates (in native C++ code) or moving through one or more output execution pins (in Blueprints). This enables Abilities to execute across multiple frames, and to perform several distinct functions in the same frame. Most Ability Tasks have an execution pin that fires immediately, enabling Blueprint execution to continue after starting a Task. In addition, there are often task-specific pins that will fire after a delay, or following a certain event that may or may not happen.</p> <p>Ability Tasks can self-terminate by calling the EndTask function, or it can wait to be terminated automatically when the Gameplay Ability that ran it ends. This prevents phantom Ability Tasks from running, effectively leaking CPU cycles and memory. For example, one Ability Task might play a spell-casting animation while another places a targeting reticule at the player's aim point. The Gameplay Ability could end if the player either hits the Confirm input to cast the spell, or waits for the animation to finish without confirming the spell. Although they can self-terminate at any time, the Ability Tasks are guaranteed to end, at latest, when the main Ability ends.</p> <p>NOTE:</p> <p><code>Ability Tasks are designed to be used in both networked and non-networked environments, although they do not directly update themselves across the network. They generally stay in sync indirectly, since they are created by Gameplay Abilities (which do replicate), and use replicated information, such as player input or networked variables, to determine their execution flow.</code></p> <p>Taken from : Official Documentation</p>"},{"location":"howtogameplayability/","title":"How-to Gameplay Ability","text":""},{"location":"howtogameplayability/#what-is-a-gameplay-ability","title":"What is a Gameplay Ability?","text":"<p>A Gameplay Ability is an ingame action that an Actor can own and trigger repeatedly. Common examples include spells, special attacks, or effects triggered by items. This concept is very common in video games, so much so it is often taken for granted, though the processes involved in running an ability are often complex and require specific timing. For example, while coding an attack activation is fairly simple in itself, over the course of a long-term project the complexity of building abilities can explode as you add resource costs, buff or debuff effects to add or remove from players, combo systems, and other details. As such, there are three major considerations involved in how Unreal Engine's Gameplay Ability System is designed. </p> <p>GameplayAbilities run on the owning client and/or the server depending on the Net Execution Policy but not simulated proxies. The Net Execution Policy determines if a GameplayAbility will be locally predicted. They include default behavior for optional cost and cooldown GameplayEffects. GameplayAbilities use AbilityTasks for actions that happen over time like waiting for an event, waiting for an attribute change, waiting for players to choose a target, or moving a Character with Root Motion Source. Simulated clients will not run GameplayAbilities. Instead, when the server runs the ability, anything that visually needs to play on the simulated proxies (like animation montages) will be replicated or RPC'd through AbilityTasks or GameplayCues for cosmetic things like sounds and particles.</p> <p>All GameplayAbilities will have their ActivateAbility() function overriden with your gameplay logic. Additional logic can be added to EndAbility() that runs when the GameplayAbility completes or is canceled.</p> <p>Flowchart of a simple GameplayAbility:  </p> <p>Flowchart of a more complex GameplayAbility:  </p> <p>GASDocumentation</p>"},{"location":"howtogameplayability/#coordinating-an-abilitys-execution","title":"Coordinating an Ability's Execution","text":"<p>An ability must be able to interact with multiple different systems during its execution, with specific timing. These interactions can include:</p> <ol> <li>Activating animation montages.</li> <li>Taking temporary control of a character's movement.</li> <li>Triggering visual effects.</li> <li>Performing overlap or collision events.</li> <li>Changing characters' stats, either temporarily or permanently.</li> <li>Increasing or decreasing ingame resources.</li> <li>Allowing or blocking the activation of other abilities.</li> <li>Handling cooldowns to restrict ability usage.</li> <li>Getting interrupted by ingame events.</li> <li>Canceling other abilities in-progress.</li> <li>Making major state changes to a character, such as activating a new movement mode.</li> <li>Responding to input in the middle of other interactions.</li> <li>Updating UI elements to show ingame status for abilities. </li> </ol> <pre><code>Depending on how an ability works, it could perform any of these interactions at many different points in time while it is active, including in the middle of animations, and some effects may need to persist after the ability itself completes. \n</code></pre>"},{"location":"howtogameplayability/#handling-abilities-and-their-execution","title":"Handling Abilities and Their Execution","text":"<p>A Gameplay Ability is a Blueprint object that is responsible for executing all of an ability's events, including playing animations, triggering effects, fetching attributes from its owner, and displaying visual effects. </p> <p><code>Controlling Activation</code> You can Activate Gameplay Abilities through four main methods:</p> <ol> <li> <p>You can activate an Ability explicitly through Blueprint or C++ code using a Gameplay Ability Handle. This is provided by the Ability System Component when an Ability is granted.</p> </li> <li> <p>Using Gameplay Events. This fires all abilities with a matching Ability Trigger. If you need to abstract your input and decision mechanisms, this method is preferable, as it provides the greatest degree of flexibility.</p> </li> <li> <p>Using Gameplay Effects with matching tags. This fires all abilities with a matching Ability Trigger. This is the preferred method for triggering abilities off of Gameplay Effects. A typical use case would be a Sleep debuff, which triggers an ability that plays a disabled animation and inhibits other game actions.</p> </li> <li> <p>Using Input Codes. These are added to the Ability System Component, and when called they will trigger all Abilities that match. This functions similarly to Gameplay Events. </p> </li> </ol> <p>TIP:</p> <pre><code>Gameplay Abilities can represent a wide array of ingame actions, and are not limited to powers or spells that players explicitly use. Hit reactions, or the above example of a Sleep animation, are good examples.\n</code></pre> <p>When you Activate a Gameplay Ability, the system recognizes that ability as being in-progress. It then fires off any code attached to the Activate event, moving through each function and Gameplay Task until you call the Finish function to signal the ability is finished executing. You can attach further code to the On Finished event if you need to do any extra cleanup. You can also Cancel an ability to stop it mid-execution.</p> <p>Gameplay Abilities use Gameplay Tags to limit execution. All abilities have a list of tags that they add to their owning Actor when they activate, as well as lists of tags that block activation or automatically cancel that ability. While you can manually cancel, block, or allow abilities' execution with your own code, this provides a method that is systemically consistent. </p>"},{"location":"howtogameplayability/#attribute-sets-and-attributes","title":"Attribute Sets and Attributes","text":"<p>The Gameplay Ability System interacts with Actors mainly through Attribute Sets, which contain Gameplay Attributes. These are numeric, floating point values that can be used in calculations or modified by Gameplay Abilities. These can be used for any purpose you want, but common use-cases include tracking a character's health or hit points, as well as values for a character's core statistics (such as Strength and Intelligence). While you can use basic variables to represent these values, Gameplay Attributes provide several advantages:</p> <ol> <li> <p>Attribute Sets provide a consistent, reusable group of attributes that you can build systems around.</p> </li> <li> <p>Gameplay Abilities can access Gameplay Attributes through reflection, making it possible to create simple calculations and effects directly in the Blueprint editor.</p> </li> <li> <p>Gameplay Attributes track their default value, current value, and maximum value separately, making it easier to create temporary modifications (buffs and debuffs) and persistent effects. Gameplay Attributes also replicate their value to all clients, and are safe for local UI visualizations such as enemy health bars. </p> </li> </ol> <p>For an Actor to use Gameplay Attributes, you must add an Attribute Set to its Ability System Component. After that, the Ability System Component can automatically access the attributes you assigned to the Attribute Set. </p>"},{"location":"howtogameplayability/#handling-gameplay-effects","title":"Handling Gameplay Effects","text":"<p>The Gameplay Ability System uses Gameplay Effects to apply changes to Actors targeted by Gameplay Abilities. These can be one-shot effects, such as applying damage, or persistent effects, such as ongoing poison damage, buffs, and debuffs. In the case of persistent effects, the Gameplay Effect attaches itself to the target Actor until it is removed, and they can be pre-set to have a limited lifetime before they expire and clean themselves up, undoing any changes to the target Actor's Gameplay Attributes.</p> <p>Gameplay Effects use Gameplay Effect Calculations to handle calculations based on Gameplay Attributes. While you can create simple calculations directly in the Blueprint editor, you can also program custom Effect Calculations that have more complex logic and affect multiple attributes at a time. These are able to process information from both the owning Actor of the Gameplay Ability and the target Actor, so you can concentrate common calculations into one reusable piece of code. </p> <p>Taken from : Official Documentation</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#as-a-project-plugin","title":"As a project plugin","text":"<ol> <li>Download the plugin from the Unreal Engine\u2019s Marketplace</li> <li>Navigate to your project folder and create a folder called \u201cplugins\u201d</li> <li>Navigate to your launcher\u2019s version of Unreal Engine folder and copy and paste  the plugin to your \u201cplugins\u201d folder <code>C:\\Program Files (x86)\\Epic Games\\UE_Latest\\Engine\\Plugins\\Marketplace</code></li> <li>Right click on you <code>.uproject</code> and generate visual studio project file</li> <li>Click your <code>.sln</code> and build your project target</li> <li>Start your project</li> <li>Enable it in your project\u2019s plugins by <code>Edit-&gt;Plugins-&gt;CommonGAS</code></li> </ol>"},{"location":"installation/#as-a-engine-plugin","title":"As a Engine plugin","text":"<ol> <li>Download the plugin from the Unreal Engine\u2019s Marketplace</li> <li>Start your Project</li> <li>Enable it in your project\u2019s plugins by <code>Edit-&gt;Plugins-&gt;CommonGAS</code></li> </ol>"},{"location":"installation/#opening-your-project-with-commongas-for-the-first-opening","title":"Opening your project with CommonGAS for the first opening","text":"<p>When you first open your project with CommonGAS enabled, you will see the following message in your message log</p> <p></p> <p>Dont panic! This is not an error, this is a validation check from the <code>Game Features plugin</code> comes by default when you enabled the plugin and since CommonGAS use this plugin for our GameFeatureAction.</p> <p>Upon clicking the link <code>Add entry to PrimaryAssetsTypesToScan?</code>, you should be prompt with a message to restart the editor.Once your editor is restarted,<code>DefaultGame.ini</code> file will be updated accordingly and those validation errors won't appear anymore.</p>"},{"location":"playmontageandwaitforevent/","title":"PlayMontageAndWaitForEvent","text":"Name Types Task Instance Name (Input) FName Montage To Play (Input) UAnimMontage Event Tags (Input) GameplayTagContainer Rate (Input) Float Start Section (Input) FName Stop when Ability Ends (Input) Boolean Anim Root Motion Translation Scale (Input) Float Name Types Async Task (Output) On Completed (Output) The montage completely finished playing On Blend Out (Output) The montage started blending out On Interrupted (Output) The montage was interrupted On Cancelled (Output) The ability task was explicitly cancelled by another ability Event Received (Output) One of the triggering gameplay events happened Event Tags (Output) GameplayTag Event Data (Output) GameplayEventData"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<ol> <li>Enable the Gameplay Ability System Plugin in the Edit -&gt; Plugins window. </li> <li>To get the full range of capabilities of this system, add \"GameplayAbilities\", \"GameplayTags\", and \"GameplayTasks\" to PublicDependencyModuleNames in your project's \"(ProjectName).Build.cs\" file.</li> </ol> <p>To use the Gameplay Ability System, add the three module names anywhere in the braced list, as follows: </p> <pre><code>PublicDependencyModuleNames.AddRange(new string[] { \"GameplayAbilities\", \"GameplayTags\", \"GameplayTasks\" });\n</code></pre>"},{"location":"setup/#setting-with-a-fresh-project","title":"Setting with a fresh project","text":"<p>In this setup, we will be using the <code>Third Person BP template</code> for our initial project setup. </p> <ul> <li> <p>Create that project by launching the Unreal Engine instance and choose Third Person Project with Blueprint as the project default. </p> </li> <li> <p>Set your project location and name your project and create the project.</p> </li> <li>Go to <code>Tools-&gt;New c++ class</code> and find <code>UAssetManager</code> and create your assetmanager.</li> </ul> <p> </p> <ul> <li>Open your IDE and add this code in your header and cpp file.</li> </ul> <p>Header:</p> <pre><code>public:\n\n    static UMyAssetManager&amp; Get();\n\n    /** Starts initial load, gets called from InitializeObjectReferences */\n    virtual void StartInitialLoading() override;\n\n</code></pre> <p>CPP:</p> <pre><code>#include \"AbilitySystemGlobals.h\"\n\n\nUMyAssetManager&amp; UMyAssetManager::Get() \n{\n    UMyAssetManager* Singleton = Cast&lt;UMyAssetManager&gt;(GEngine-&gt;AssetManager);\n\n    if (Singleton)\n    {\n        return *Singleton;\n    }\n    else\n    {\n        UE_LOG(LogTemp, Fatal, TEXT(\"Invalid AssetManager in DefaultEngine.ini, must be MyAssetManager!\"));\n        return *NewObject&lt;UMyAssetManager&gt;();    // never calls this\n    }\n}\n\n\nvoid UMyAssetManager::StartInitialLoading() \n{\n    Super::StartInitialLoading();\n    UAbilitySystemGlobals::Get().InitGlobalData();\n}\n</code></pre> <p>Starting in UE 4.24, it is now necessary to call <code>UAbilitySystemGlobals::Get().InitGlobalData()</code> to use TargetData, otherwise you will get errors related to <code>ScriptStructCache</code> and clients will be disconnected from the server. This function only needs to be called <code>once in a project</code>.  Fortnite calls it from <code>UAssetManager::StartInitialLoading()</code> so thats why we do the same.</p> <ul> <li>Next, go to your <code>Config/DefaultEngine.ini</code> and add this into your <code>[/Script/Engine.Engine]</code></li> </ul> <pre><code>[/Script/Engine.Engine]\nAssetManagerClassName=/Script/CommonExampleProject.MyAssetManager\n</code></pre> <ul> <li>Find the <code>ThirdPerson</code> folder and find your GameMode class. Reparent your game mode class to <code>CommonModularGameMode.h</code> </li> <li>Find the <code>ThirdPerson</code> folder and find your Character class. Reparent your character class to <code>CommonModularCharacter.h</code> </li> <li>Right click, go to blueprint and create a <code>PlayerState class</code>. Reparent your player state class to <code>CommonModularPlayerState.h</code> </li> <li>Right click, go to blueprint and create a <code>PlayerController class</code>. Reparent your player controller class to <code>CommonModularPlayerController.h</code></li> </ul> <p>Once you finish, find the three dot near <code>Play</code> button, find <code>NetMode</code> and choose <code>Play As Client</code>.</p> <p> </p> <p>Then, press Play. If we setup everything correctly, we should get no error. To confirm that, enter this command into the console command <code>showdebug abilitysystem</code> and you will be greeted with this debug panel.</p> <p></p>"},{"location":"setup/#setting-up-with-preexisting-project","title":"Setting up with Preexisting Project","text":"<ul> <li>Go to <code>Tools-&gt;New c++ class</code> and find <code>UAssetManager</code> and create your assetmanager.</li> </ul> <ul> <li>Open your IDE and add this code in your header and cpp file.</li> </ul> <p>Header:</p> <pre><code>public:\n\n    static UMyAssetManager&amp; Get();\n\n    /** Starts initial load, gets called from InitializeObjectReferences */\n    virtual void StartInitialLoading() override;\n\n</code></pre> <p>CPP:</p> <pre><code>#include \"AbilitySystemGlobals.h\"\n\n\nUMyAssetManager&amp; UMyAssetManager::Get() \n{\n    UMyAssetManager* Singleton = Cast&lt;UMyAssetManager&gt;(GEngine-&gt;AssetManager);\n\n    if (Singleton)\n    {\n        return *Singleton;\n    }\n    else\n    {\n        UE_LOG(LogTemp, Fatal, TEXT(\"Invalid AssetManager in DefaultEngine.ini, must be MyAssetManager!\"));\n        return *NewObject&lt;UMyAssetManager&gt;();    // never calls this\n    }\n}\n\n\nvoid UMyAssetManager::StartInitialLoading() \n{\n    Super::StartInitialLoading();\n    UAbilitySystemGlobals::Get().InitGlobalData();\n}\n</code></pre> <p>Starting in UE 4.24, it is now necessary to call <code>UAbilitySystemGlobals::Get().InitGlobalData()</code> to use TargetData, otherwise you will get errors related to <code>ScriptStructCache</code> and clients will be disconnected from the server. This function only needs to be called <code>once in a project</code>.  Fortnite calls it from <code>UAssetManager::StartInitialLoading()</code> so thats why we do the same.</p> <ul> <li>Next, go to your <code>Config/DefaultEngine.ini</code> and add this into your <code>[/Script/Engine.Engine]</code></li> </ul> <pre><code>[/Script/Engine.Engine]\nAssetManagerClassName=/Script/CommonExampleProject.MyAssetManager\n</code></pre> <ul> <li>Reparent your character class to CommonModularCharacter.h</li> <li>Reparent your player controller class to CommonModularPlayerController.h</li> <li>Reparent your player state class to CommonModularPlayerState.h</li> <li>Reparent your game mode class to CommonModularGameMode.h</li> </ul> <p>To see if you configured CommonGAS correctly, go to the command bar and use the following command:</p> <p><code>showdebug abilitysystem</code></p> <p></p>"},{"location":"setup/#using-enhanced-input-system","title":"Using Enhanced Input System","text":"<p>From Unreal Engine 5.1 onwards, the EnhancedInput plugin will replace the legacy input system. If your project is from Unreal Engine 5.0 and below, make sure to enable the EnhancedInput Plugin by:</p> <p><code>Plugins-&gt;Input-&gt;EnhancedInput</code></p> <p>By default, the <code>Third Person template</code> preconfigured to use EnhancedInputSystem and there's some setup configured. </p> <p>We can just use the preconfigured Binding system on <code>BeginPlay</code> or using <code>CommonAbilityInputBinding</code> component.In this setup, we want to use the component as it comes with some convenience functions for input binding.</p> <ul> <li>Find your blueprint character class and open it</li> <li>Go to the Component Section and Add the CommonAbilityInputBindingComponent</li> </ul> <p></p> <p>We can delete the <code>BeginPlay</code> setup and use the component to bind our input mapping context. The <code>Third Person template</code> also comes with preconfigured <code>InputActions</code> and <code>InputMappingContext</code> in <code>ThirdPerson/Input</code> folder.</p> <ul> <li>Find CommonGAS -&gt;PlayerControls category and configure your Mapping Context by using the <code>IMC_Default</code> that comes with the template</li> </ul> <p></p> <p>What this component does is essentially the same with what the <code>BeginPlay</code> event does above.</p> <p>Note:</p> <pre><code>In the future, im planning to revamp this system so you can configured what IMC when you're enter the Death event and what IMC you will rebind for Death and Respawn system\n</code></pre> <p>To see if you configure Enhanced Input correctly, go to the command bar and use the following command:</p> <p><code>showdebug enhancedinput</code></p> <p></p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#how-does-enhancedinput-works-with-commongas","title":"How does EnhancedInput Works with CommonGAS","text":""},{"location":"whatisgamefeatures/","title":"What is Game Features","text":"<p>The Game Features and Modular Gameplay plugins help developers create standalone features for their projects. Building features with these plugins offers several benefits, including keeping your project's codebase clean and readable, and avoiding accidental interactions or dependencies between unrelated features. This is particularly important when developing live products that change their feature sets over time. Official Documentation</p> <p>By default, there are four <code>game features action</code> available for you.</p> Name Functionality Add Cheats Action extend the Cheat Manager, creating new \"cheat codes\" or extending existing ones. Cheat codes are helpful for debugging, and are    automatically removed from shipping builds. The ~ (tilde) key opens the console where you can enter these codes while running your project. Add Components Actions take a list of Actor subclasses and add a set of Components to them on an opt-in basis. This is the most common way to use the Game Features and Modular Gameplay plugins, since Components are well-suited to encapsulating a wide range of behaviors. Add Data Registry Actions add one or more Data Registries to the project. Data Registries are efficient places to store and retrieve globally-registered data. Add Data Registry Source Actions add one or more Data Tables to existing Data <p>In CommonGAS, we provided you GameFeatureAction for GameplayAbilitySystem taken from ValleyOfTheAncientDemo and LyraGameSample</p> Name Functionality Add Abilities Add gameplay abilities and gameplay effects when enabled and remove gameplay abilities and gameplay effects when disabled Add InputMappingContext Add an InputMappingContext when enabled and remove an InputMappingContext when disabled"}]}